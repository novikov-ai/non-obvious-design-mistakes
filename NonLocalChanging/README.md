# Нелокальные изменения в проекте

В рабочем сервисе, который отвечал за горизонтальную логику, то есть был точкей входа для множества вертикальных фичей, появилась необходимость сделать рефактор. Основная причина была в том, что в общей функции выполнялась вертикально-специфичная логика, которая должна быть инкапсулирована отдельно. Иначе создавалось много визуального шума, из-за чего сильно ухудшалась читаемость и возможности для дальнейшей поддержки. 

~~~go
func process(){
    // general horizontal logic
    // ...

    if item != nil && item.ID == verticalID {
        // vertical logic
        // ...
    }

    // general horizontal logic
    // ...
}
~~~

Первой мыслью было взять "кусок" этой логики и перенести в отдельную функцию, которая уменьшила бы визуальный шум в общем коде:

~~~go
func process(){
    // general horizontal logic
    // ...

    // vertical logic
    processVerticalFeature()

    // general horizontal logic
    // ...
}

// vertical logic
func processVerticalFeature(){
    // ...
    if item == nil{
        return
    }
    if item.ID == verticalID {
       // ...
    }
    // ...
}
~~~

Такой подход, конечно, помог бы, но несильно, так как сервис все равно будет состоять из этой логики, а, если другие вертикальные команды будут следовать этому примеру, то рано или поздно, сервис будет настолько грязным, что его трудно будет поддерживать. 

Появилась идея организовать универсальный способ работы с вертикально-специфичной логикой из своих отдельных репозиториев. Так был сделан общий интерфейс, который описывал поведение для вертикальных потребителей. 

В общем коде нужно было лишь поддержать простой цикл, который вызывал бы логику из вертикальных библиотек, используя общий интерфейс `VerticalModifier`. Такой интерфейс необходимо было реализовать в отдельной библиотеке, что значительно упростило доставку новых фичей и поддержку существующих. Основной код писался в вертикальной библиотеке, а в сервисе требовалось лишь поднять версию используемой зависимости. 

Этапы рефакторинга: 
1. Объявить общий интерфейс для работы с вертикальной логикой.
2. Добавить в месте по работе с данными цикл, который проходился бы по коллекции вертикальных интерфейсов и вызывал их по очереди в произвольном порядке.
3. Унести вертикально-специфичную логику к себе в отдельную библиотеку, где живут все вертикальные фичи, и реализовать общий интерфейс с этой логикой. 
4. Убедиться, что ничего не сломали и юнит-тесты проходят. 

Конечный код выглядит следующим образом:

~~~go
// horizontal service

func process(){
    // general horizontal logic
    // ...

    // general vertical modifiers
    for _, vm := modifiers{
        vm.Modify()
    }

    // general horizontal logic
    // ...
}

type VerticalModifier interface{
    Modify()
}
~~~

~~~go
// vertical library

type VerticalModifier interface{
    Modify()
}

func Modify(){
    // vertical logic
    // ...

    if item == nil{
        return
    }
    if item.ID == verticalID {
       // ...
    }

    // ...
}
~~~